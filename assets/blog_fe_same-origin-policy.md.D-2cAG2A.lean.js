/* empty css                                                               */import{_ as i,c as s,a8 as e,o as l}from"./chunks/framework.CEV-pc2D.js";const u=JSON.parse('{"title":"同源策略","description":null,"frontmatter":{"description":null,"layoutClass":"fuye-single-page-layout","outline":[2,3,4]},"headers":[],"relativePath":"blog/fe/same-origin-policy.md","filePath":"blog/fe/same-origin-policy.md"}'),n={name:"blog/fe/same-origin-policy.md"};function t(o,a,r,h,d,p){return l(),s("div",null,a[0]||(a[0]=[e(`<h1 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h1><p>浏览器实施同源策略（Same-Origin Policy，SOP）​的核心目的是保障用户隐私和数据安全，防止恶意网站通过跨域请求窃取或篡改敏感信息。</p><h2 id="一、同源策略的定义与判定标准" tabindex="-1">一、同源策略的定义与判定标准 <a class="header-anchor" href="#一、同源策略的定义与判定标准" aria-label="Permalink to &quot;一、同源策略的定义与判定标准&quot;">​</a></h2><h3 id="​同源的定义" tabindex="-1">​同源的定义 <a class="header-anchor" href="#​同源的定义" aria-label="Permalink to &quot;​同源的定义&quot;">​</a></h3><p>两个 URL 的以下<strong>三要素</strong>必须完全一致才能视为同源：</p><ul><li>​协议​（如 HTTP/HTTPS）</li><li>​域名​（包括子域名，如 <code>www.example.com</code> 与 <code>api.example.com</code> 不同源）。</li><li>​端口​（默认端口可省略，如HTTP默认 <code>80</code> 端口、HTTPS 默认 <code>443</code> 端口）。</li></ul><h3 id="​例外情况" tabindex="-1">​例外情况 <a class="header-anchor" href="#​例外情况" aria-label="Permalink to &quot;​例外情况&quot;">​</a></h3><p>即使跨域，以下资源加载不受限制（但脚本无法直接操作内容）：</p><ul><li><code>&lt;img&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code>等标签加载的静态资源（如图片、JavaScript、CSS）</li><li><code>&lt;iframe&gt;</code>加载的页面（但无法通过 JavaScript 访问其 DOM）</li></ul><h2 id="二、同源策略的具体限制" tabindex="-1">二、同源策略的具体限制 <a class="header-anchor" href="#二、同源策略的具体限制" aria-label="Permalink to &quot;二、同源策略的具体限制&quot;">​</a></h2><h3 id="​dom访问隔离" tabindex="-1">​DOM访问隔离 <a class="header-anchor" href="#​dom访问隔离" aria-label="Permalink to &quot;​DOM访问隔离&quot;">​</a></h3><p>跨域页面间无法通过 JavaScript 互相操作 DOM。</p><p>例如，<code>a.com</code> 的脚本无法读取 <code>b.com</code> 页面的表单内容或元素属性。</p><h3 id="​数据存储隔离" tabindex="-1">​数据存储隔离 <a class="header-anchor" href="#​数据存储隔离" aria-label="Permalink to &quot;​数据存储隔离&quot;">​</a></h3><ul><li><code>Cookie</code>：仅允许同源页面访问（除非设置domain属性为父域名）。</li><li><code>LocalStorage</code>、<code>IndexDB</code>：完全禁止跨域访问。</li></ul><h3 id="网络请求拦截" tabindex="-1">网络请求拦截 <a class="header-anchor" href="#网络请求拦截" aria-label="Permalink to &quot;网络请求拦截&quot;">​</a></h3><ul><li><code>AJAX/Fetch</code> 请求：默认禁止跨域，浏览器会返回CORS错误。 ​- <code>WebSocket</code>：不受同源策略限制，但需服务器显式允许连接。</li></ul><h3 id="跨窗口通信限制" tabindex="-1">跨窗口通信限制 <a class="header-anchor" href="#跨窗口通信限制" aria-label="Permalink to &quot;跨窗口通信限制&quot;">​</a></h3><p>不同源的窗口或框架间无法直接通过 <code>window.postMessage()</code> 以外的API通信。</p><h2 id="三、绕过同源策略的安全方法" tabindex="-1">三、绕过同源策略的安全方法 <a class="header-anchor" href="#三、绕过同源策略的安全方法" aria-label="Permalink to &quot;三、绕过同源策略的安全方法&quot;">​</a></h2><p>尽管同源策略严格，但合法场景下的跨域交互可通过以下方式实现：</p><h3 id="cors-跨域资源共享" tabindex="-1">CORS（跨域资源共享） <a class="header-anchor" href="#cors-跨域资源共享" aria-label="Permalink to &quot;CORS（跨域资源共享）&quot;">​</a></h3><ul><li>​原理：服务器通过响应头（如 <code>Access-Control-Allow-Origin</code>）声明允许的源、方法和头信息。</li><li>​流程： <ul><li>​简单请求：直接发送请求，依赖服务器响应头授权（如 GET/POST 且无特殊头）。</li><li>​预检请求​（OPTIONS）：非简单请求（如 PUT/DELETE 或自定义头）需先发送预检请求验证权限。</li></ul></li><li>Nginx配置示例：</li></ul><div class="language-nginx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">location</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> / </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($request_method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">= </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;OPTIONS&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        add_header </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Origin&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        add_header </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Methods&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;GET, POST, OPTIONS&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        add_header </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Headers&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Content-Type, Authorization&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 204</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    add_header </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Origin&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><span style="color:red;">（注：生产环境应替换 * 为具体域名以提升安全性）</span></p><h3 id="jsonp-json-with-padding" tabindex="-1">JSONP（JSON with Padding） <a class="header-anchor" href="#jsonp-json-with-padding" aria-label="Permalink to &quot;JSONP（JSON with Padding）&quot;">​</a></h3><p>跨域脚本调用。</p><ul><li>​原理：利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特性，动态插入脚本并通过回调函数获取数据。</li><li>​局限性：仅支持 GET 请求，且需服务器返回包裹回调函数名的响应（如 <code>callback(data)</code>）。</li></ul><h3 id="​代理服务器" tabindex="-1">​代理服务器 <a class="header-anchor" href="#​代理服务器" aria-label="Permalink to &quot;​代理服务器&quot;">​</a></h3><ul><li>​实现：通过同源的后端服务（如 Nginx）转发请求，隐藏真实跨域目标。</li><li>​示例：前端请求 <code>/api/data</code>，Nginx 代理转发至 <code>backend-server:8081/api/data</code>。</li></ul><h3 id="postmessage-api" tabindex="-1">postMessage API <a class="header-anchor" href="#postmessage-api" aria-label="Permalink to &quot;postMessage API&quot;">​</a></h3><ul><li>​用途：安全实现跨窗口通信（如父子页面间传递消息）。</li><li>​安全建议：始终验证消息来源（<code>event.origin</code>）并限制目标窗口。</li></ul><h2 id="四、同源策略的安全意义" tabindex="-1">四、同源策略的安全意义 <a class="header-anchor" href="#四、同源策略的安全意义" aria-label="Permalink to &quot;四、同源策略的安全意义&quot;">​</a></h2><ul><li>​防御XSS/CSRF攻击：阻止恶意脚本窃取用户会话Cookie或伪造请求。</li><li>​隔离敏感数据：确保不同域的数据存储（如银行网站与社交网站）互不干扰。</li><li>​平衡灵活性与安全：通过CORS等机制在安全前提下支持合法跨域需求。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>浏览器通过同源策略构建了基础安全防线，开发者需理解其限制并通过 CORS 等可控方式实现跨域交互。合理配置服务器响应头（如 <code>Access-Control-Allow-Origin</code>）是解决跨域问题的核心，同时需避免过度开放权限（如滥用通配符 <code>*</code>）以降低安全风险。</p>`,36)]))}const g=i(n,[["render",t]]);export{u as __pageData,g as default};
